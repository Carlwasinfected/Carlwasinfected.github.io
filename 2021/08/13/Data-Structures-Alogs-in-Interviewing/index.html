<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Carl">





<title>Data Structures &amp; Alogs in Interviewing | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Carl&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Carl&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Data Structures &amp; Alogs in Interviewing</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Carl</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 13, 2021&nbsp;&nbsp;22:26:53</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="快排-amp-快选"><a href="#快排-amp-快选" class="headerlink" title="快排 &amp; 快选"></a>快排 &amp; 快选</h1><blockquote>
<p>Reference: </p>
<ul>
<li>quick select wiki:<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quickselect">https://en.wikipedia.org/wiki/Quickselect</a></li>
</ul>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>快选类似快排, 但是只向目标区间这一边递归, 因此时间复杂度是<strong>O(n)</strong>. 快排逃不了两边都要一直分别递归下去, 因此复杂度是<strong>O(nlogn)</strong></p>
<blockquote>
<p><em>As with quicksort, quickselect is generally implemented as an <em>in-place</em> algorithm, and beyond selecting the <em>k</em>th element, it also partially sorts the data.</em></p>
</blockquote>
<p><strong>快选:比堆更快地找到数组的第kth min/max元素; 但是小心函数爆栈</strong></p>
<p>注意以下几个要点 👇</p>
<ol>
<li>搜索区间是[left, right], 也就是说两者都是incluisve的. 一开始传参需要注意<code>[0, len-1]</code></li>
<li><code>partition()</code>函数有<strong>三个阶段的swap</strong> </li>
<li><code>lst[cur_idx]</code>总是落后于<code>lst[i]</code>.  由于我们是遍历<code>lst[i]</code>, 因此判断的是如果<code>lst[i]</code><strong>大于</strong>枢纽元,则把它互换,扔给前面<code>cur_idx</code>那个位置.  <em>「以从小到大排序为例」</em></li>
<li>别忘了如果<code>cur_idx</code>何时++</li>
</ol>
<p><strong>快排</strong> </p>
<h2 id="快选例题"><a href="#快选例题" class="headerlink" title="快选例题"></a>快选例题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-a-stream/"><strong>703. Kth Largest Element in a Stream</strong></a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: List[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">    self.l = nums</span><br><span class="line">    self.targetidx = <span class="built_in">len</span>(self.l) - k</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="comment"># 1. update target index</span></span><br><span class="line">    self.targetidx += <span class="number">1</span></span><br><span class="line">    self.l.append(val)</span><br><span class="line">    ans =  self.quickselect(<span class="number">0</span>,<span class="built_in">len</span>(self.l)-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickselect</span>(<span class="params">self, left, right</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> left == right:</span><br><span class="line">        <span class="keyword">return</span> self.l[left]</span><br><span class="line">    </span><br><span class="line">    pivotidx = random.randint(left, right)</span><br><span class="line">    pivotidx = self.partition(left, right, pivotidx)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pivotidx == self.targetidx:</span><br><span class="line">        <span class="keyword">return</span> self.l[pivotidx]</span><br><span class="line">    <span class="keyword">elif</span> pivotidx &lt; self.targetidx:</span><br><span class="line">        <span class="keyword">return</span> self.quickselect(pivotidx+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.quickselect(left, pivotidx-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, left, right, pidx</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;return the real index of unsorted arr[pivotidx]&quot;&quot;&quot;</span></span><br><span class="line">    pval = self.l[pidx]</span><br><span class="line">    <span class="comment"># first swap</span></span><br><span class="line">    self.l[pidx], self.l[right] = self.l[right], self.l[pidx]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># second swap</span></span><br><span class="line">    cur_idx = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right): <span class="comment"># 注意left, right本身都是inclusive的, 因此右边界是 right-1而不是-2</span></span><br><span class="line">        <span class="keyword">if</span> self.l[i] &lt; pval: <span class="comment"># 注意 </span></span><br><span class="line">            self.l[cur_idx],  self.l[i] = self.l[i], self.l[cur_idx]</span><br><span class="line">            cur_idx += <span class="number">1</span> <span class="comment"># 注意. Hit if 才++</span></span><br><span class="line">    <span class="comment"># third swap</span></span><br><span class="line">    self.l[right], self.l[cur_idx] = self.l[cur_idx], self.l[right]</span><br><span class="line">    <span class="keyword">return</span> cur_idx</span><br></pre></td></tr></table></figure>



<p><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;amazon 2021 vo : https://www.1point3acres.com/bbs/thread-787220-1-1.html&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Quick Select O(N)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right, pivot_idx</span>):</span></span><br><span class="line">            pivot = nums[pivot_idx]</span><br><span class="line">            <span class="comment">#1. swap pivot to the end</span></span><br><span class="line">            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#2. compare nums[i] with pivot; move all smaller element to the left</span></span><br><span class="line">            store_idx = left <span class="comment"># 注意 不是0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):  <span class="comment"># 迭代区间[left, right-1] 注意right已经是len-1</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                    <span class="comment"># swap</span></span><br><span class="line">                    nums[store_idx], nums[i] = nums[i], nums[store_idx]</span><br><span class="line">                    store_idx += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 3. move pivot to its final place</span></span><br><span class="line">            nums[store_idx], nums[right] = nums[right], nums[store_idx]</span><br><span class="line">            <span class="keyword">return</span> store_idx</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickselect</span>(<span class="params">left, right, target_idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                <span class="keyword">return</span> nums[left]  <span class="comment"># answer1</span></span><br><span class="line">            </span><br><span class="line">            pivot_idx = random.randint(left, right)</span><br><span class="line">            pivot_idx = partition(left, right, pivot_idx)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> target_idx == pivot_idx:</span><br><span class="line">                <span class="keyword">return</span> nums[target_idx] <span class="comment"># answer2</span></span><br><span class="line">            <span class="keyword">elif</span> target_idx &lt; pivot_idx:</span><br><span class="line">                <span class="keyword">return</span> quickselect(left, pivot_idx-<span class="number">1</span>, target_idx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> quickselect(pivot_idx+<span class="number">1</span>, right, target_idx)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> quickselect(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="built_in">len</span>(nums)-k)</span><br></pre></td></tr></table></figure>



<h1 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h1><p><strong>单调栈</strong></p>
<p>When: 需要找到数组中当前元素的<strong>“下一个更大元素”</strong></p>
<p>特点: 栈中元素都是单调递增或者单调递增的. 如果求下一个更大的元素, 显然要求出栈的序列是递增的「否则可能出现下二个更大元素. 那么要求<strong>入栈的序列是递减</strong>的, 比如<code>[6, 3, 2, 1</code>   也就是说遍历过程中遇到大于等于栈顶的元素需要一直pop,知道栈顶元素小于遍历元素.   </p>
<blockquote>
<p>e.g., <code>[6, 3, 2, 1</code> 遇到了4, 那么要依次pop掉1,2,3; ==&gt;  <code>[6,4</code></p>
</blockquote>
<p>所以单调栈是靠<strong>删除『pop操作』</strong>来保证容器内的单调性的. 后面的单调队列也是如此.</p>
<p>又因为“下一个” 代表着要在找索引比当前元素更大的区间里搜索. 所以可知以下两个特点 👇👇</p>
<blockquote>
<ol>
<li>从数组结尾往前遍历</li>
<li>只让比当前栈顶元素大的入栈, 如果不满足, 那么一直pop栈顶直到空</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “下一个更大元素“的模版 </span></span><br><span class="line"></span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):<span class="comment"># from end to 0</span></span><br><span class="line">    <span class="comment"># 如果栈顶小于等于元素,就一直pop; 以此维持stack**自底向上是单调减的** </span></span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> s[-<span class="number">1</span>] &lt;= arr[i]: </span><br><span class="line">        s.pop()</span><br><span class="line">    ans[i] = s[-<span class="number">1</span>] <span class="keyword">if</span> <span class="keyword">not</span> s.empty() <span class="keyword">else</span> -<span class="number">1</span> <span class="comment"># ans[i]: 第i个元素的下一个更大元素</span></span><br><span class="line">    s.append(arr[i])</span><br></pre></td></tr></table></figure>



<p><strong>单调队列</strong></p>
<h2 id="单调栈例题"><a href="#单调栈例题" class="headerlink" title="单调栈例题"></a>单调栈例题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-element-i/"><strong>\496. Next Greater Element I</strong></a></p>
<blockquote>
<img src="https://cdn.jsdelivr.net/gh/Carlwasinfected/hximgs@main/data/image-20210814005948436.png" alt="image-20210814005948436" style="zoom:50%;" />

<p>其中nums1是nums2的子集. 二者都没有重复元素</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># mono stack</span></span><br><span class="line">        <span class="comment"># Note that nums1 is subset of nums2 &amp;&amp; all elements are unique</span></span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(nums1)</span><br><span class="line">        <span class="comment">#res = 0</span></span><br><span class="line">        d =&#123;&#125; <span class="comment"># &#123;val: next greater number&#125;</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[-<span class="number">1</span>] &lt;= nums2[i]:</span><br><span class="line">                s.pop()</span><br><span class="line">            d[nums2[i]] = -<span class="number">1</span> <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">else</span> s[-<span class="number">1</span>]</span><br><span class="line">            s.append(nums2[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            ans[i] = d[nums1[i]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-element-ii/"><strong>\503. Next Greater Element II</strong></a></p>
<blockquote>
<p>找nums[i]的下个更大, 但是可以从元素右边找一圈一直找到元素左边 </p>
<p><strong>循环数组 –&gt;  索引取余</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 单调栈+循环数组  T = k*O(n) = O(n)</span></span><br><span class="line">        <span class="comment"># 1.为了找**之后**, 所以倒着遍历</span></span><br><span class="line">        <span class="comment"># 2.为了找**第一个**比nums[i]大的元素, 所以必须增序出栈, 因此入栈必须降序.即保证栈底最大,栈顶最小,且栈单调</span></span><br><span class="line">        <span class="comment"># 3. 循环数组,利用两倍长度 + i%n做索引</span></span><br><span class="line">        </span><br><span class="line">        s = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span>] * n </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[-<span class="number">1</span>] &lt;= nums[i%n]: <span class="comment"># 注意题干找大于. 因此==也要pop掉</span></span><br><span class="line">                s.pop()</span><br><span class="line">            res[i%n] = s[-<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            s.append(nums[i%n])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-node-in-linked-list/"><strong>\1019. Next Greater Node In Linked List</strong></a></p>
<blockquote>
<img src="https://cdn.jsdelivr.net/gh/Carlwasinfected/hximgs@main/data/image-20210814011149600.png" alt="image-20210814011149600" style="zoom:50%;" />
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 单调栈, 多了个遍历链表读值而已  </span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(res)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        s = [] <span class="comment"># monotonic stack</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[-<span class="number">1</span>] &lt;= res[i]:</span><br><span class="line">                s.pop()</span><br><span class="line">            <span class="keyword">if</span> s:</span><br><span class="line">                ans[i] = s[-<span class="number">1</span>]</span><br><span class="line">            s.append(res[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>





<h2 id="单调队列例题"><a href="#单调队列例题" class="headerlink" title="单调队列例题"></a>单调队列例题</h2><p>用于解决滑动窗口问题. 当你需要维持一个窗口,并保证队列头到队列尾的单调性时. </p>
<p>由于队列的FIFO特性, 因此单调队列的出栈和入栈是同向的「要么都单调递增, 要么都单调递减」 模版类似单调栈,通过比较当前元素和队头,不断pop队头直到空或者满足大小关系再加入队尾.</p>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sliding-window-maximum/">Sliding Window Maximum</a></strong></p>
<img src="https://cdn.jsdelivr.net/gh/Carlwasinfected/hximgs@main/data/image-20210816104407066.png" alt="image-20210816104407066" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    res = collections.deque()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 目标:队头元素最大, q: index of nums[i] </span></span><br><span class="line">    <span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): </span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt; val:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># maintain window size</span></span><br><span class="line">        <span class="keyword">if</span> q[<span class="number">0</span>] + k &gt;= i:</span><br><span class="line">            q.popleft()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">     <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><blockquote>
<p>Ref:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7nP92FhCTpTKIAplj_xWpA">https://mp.weixin.qq.com/s/7nP92FhCTpTKIAplj_xWpA</a></li>
</ul>
</blockquote>
<p>如果<code>a --&gt; b</code>表示<code>b</code>依赖于<code>a</code>, 即<code>b</code>必须在<code>a</code>执行之后才能执行, 那么给定一个依赖序列, 可以利用拓扑排<strong>序找到满足依赖关系的节点执行顺序</strong>, 这个过程称为拓扑排序.</p>
<blockquote>
<p>e.g., <code>graph[0] = [0, 0, 1, 1, 0]</code> 表示2和3依赖0, 必须晚于0执行.</p>
</blockquote>
<p>拓扑排序有以下性质:</p>
<p>1.拓扑排序是图<strong>后序遍历</strong>序列的<strong>reverse</strong>结果</p>
<blockquote>
<p>因为依赖关系的要求是必须自己所依赖的任务都执行完成后才能执行自己 </p>
</blockquote>
<p>2.图中不存在循环依赖. 即拓扑排序只针对<strong>有向无环图</strong>,  在DFS过程中需要对当前节点进行<strong>环检测「见下」</strong></p>
<p><strong>判断有向图有环是否需要拓扑排序?</strong></p>
<p>不用. 拓扑排序只是基于<strong>无环有向图</strong>前提下<strong>后序遍历的结果产物</strong>, 只判断有向图是否有环的话跟拓扑排序没关系. </p>
<p>只是判断是否有环, <code>DFS/BFS + seen&#123;&#125; + cur_path[]</code> 就可以了</p>
<p>模版 <strong>T = O(V+E)</strong></p>
<ol>
<li><p>基于DFS</p>
</li>
<li><p>基于入度和邻接表 </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Topological_sorting"><em>Kahn’s</em> <em>Algorithm</em></a></p>
<ol>
<li>构建好邻接表和入度表</li>
<li>把所有入度为0的点加入队列<code>zero</code> </li>
<li>如果队列不空, pop队头. 把队头加入拓扑排序的结果<code>res[]</code>  再把队头邻居的所有入度都减一「去边」, 并判断如果有入度为0的, 则加入<code>zero</code>队列</li>
<li>重复3, 直到队列空</li>
<li>如果<code>res</code>中原节点都在,那么这个图是可拓扑的. 输出<code>res</code></li>
</ol>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topsort</span>():</span></span><br><span class="line">        edges = defaultdict(<span class="built_in">list</span>) <span class="comment"># &#123;node : [neighbors]&#125;</span></span><br><span class="line">        ind = defaultdict(<span class="built_in">int</span>) <span class="comment"># &#123;node : indegree&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build </span></span><br><span class="line">        <span class="keyword">for</span> to, fro <span class="keyword">in</span> prerequisites:</span><br><span class="line">            ind[to] += <span class="number">1</span></span><br><span class="line">            edges[fro].append(to)</span><br><span class="line">        </span><br><span class="line">        zero_d = deque([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> ind])</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> zero_d:</span><br><span class="line">            cur_node = zero_d.popleft()</span><br><span class="line">            res.append(cur_node)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> edges[cur_node]:</span><br><span class="line">                ind[node] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> ind[node] == <span class="number">0</span>:</span><br><span class="line">                    zero_d.append(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> <span class="built_in">len</span>(res) == num <span class="keyword">else</span> []</span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h1 id="循环数组"><a href="#循环数组" class="headerlink" title="循环数组"></a>循环数组</h1><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><blockquote>
<p>Ref: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trie">https://en.wikipedia.org/wiki/Trie</a></p>
<p>leetcode 208:<a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-trie-prefix-tree/">https://leetcode.com/problems/implement-trie-prefix-tree/</a></p>
</blockquote>
<p>字典树是一种<strong>多叉搜索树</strong>,  每个节点的val是一个<code>char</code>,  从<code>root --&gt; current node</code>的路径可以表示字符串.</p>
<p>字典树的结构如下, <strong>一般<code>root</code>不赋值, 作为占位的哨兵节点.</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Carlwasinfected/hximgs@main/data/image-20210822075903846.png" alt="image-20210822075903846" style="zoom:50%;" />

<p><strong>字典树节点的数据结构</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    self.children = &#123;char : node that holds the char&#125; <span class="comment"># 子节点的hash table</span></span><br><span class="line">    self.val = current char  <span class="comment"># 自己的char</span></span><br><span class="line">    self.isEnd = <span class="literal">False</span>  <span class="comment"># 是否是某个word的结尾</span></span><br></pre></td></tr></table></figure>

<p><strong>字典树的数据结构「利用DFS遍历找位置」</strong></p>
<ul>
<li><p><code>search()</code> </p>
<p>  查找是否有某个<code>word</code> ==&gt; 找到最后一个char, 若能找到,return <code>self.isEnd</code></p>
</li>
<li><p><code>hasStartWith() </code>  查找是否有以某个<code>string</code>为前序的<code>string</code></p>
<p>  注意和<code>search()</code>相区别.   <strong>叶子结点一定是某个word, 但是非叶子结点不一定就不是某个word</strong> . 因此如果可以成功遍历完所有char,就<code>return True</code></p>
</li>
<li><p><code>insert()</code> :   插入某个<code>string</code></p>
<p>  DFS到插入点: <code>if current char does not exist</code>, 那么<code>new</code>一个新结点, 插入到当前节点的<code>children hash table</code>中</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.children = &#123;&#125; <span class="comment"># &#123;char : node that holds that char&#125;</span></span><br><span class="line">        self.val = val <span class="comment"># current character</span></span><br><span class="line">        self.isEnd = <span class="literal">False</span> <span class="comment"># Trie has a word ending in current node</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = Node() <span class="comment"># 占位</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ptr = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ptr.children.get(ch): <span class="comment"># found the inserted point</span></span><br><span class="line">                ptr.children[ch] = Node(ch)</span><br><span class="line">            ptr = ptr.children[ch]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># pointer ends in last char node(leaf) in the tree.</span></span><br><span class="line">        ptr.isEnd = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Find Function</span></span><br><span class="line">        ptr = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ptr.children.get(ch):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            ptr = ptr.children[ch]</span><br><span class="line">        <span class="keyword">return</span> ptr.isEnd</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Find Function</span></span><br><span class="line">        ptr = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ptr.children.get(ch):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            ptr = ptr.children[ch]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>





<h1 id="前缀和「解决子数组和的问题」"><a href="#前缀和「解决子数组和的问题」" class="headerlink" title="前缀和「解决子数组和的问题」"></a>前缀和「解决子数组和的问题」</h1><p>给定一个数组<code>nums</code>, 长度为<code>n</code>, 可以构建一个前缀和数组<code>pre_sum</code>, 长度为<code>n+1</code>,  其中<code>pre_sum[0] = 0</code>, <code>pre_sum[i]</code> 表示<code>nums[0 ... i-1]</code>的加和. 因此有<code>pre_sum[i] = pre_sum[i-1] + nums[i-1]</code></p>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a></strong></p>
<p>注意这题思路: 子数组区间sum –&gt; 前缀和 –&gt; 找到满足<code>presum[i] - presum[j] == k</code>的<code>(i, j)</code>有多少个.</p>
<p>因此对于这题, 我们不需要开一个<code>pre_sum</code>数组, 因为我们并不关心前缀和的位置. 我们只关心前缀和为某个值的子数组有多少个, 而不关心他在哪等其他信息.</p>
<p>于是可以用<code>hash table</code>优化. <code>&#123;前缀和 : 前缀和出现的次数&#125;</code>. <strong>对于前缀和为<code>cur_sum</code>, 我们期待找前缀和为<code>cur_sum - k</code>的次数.</strong></p>
<p>时间复杂度: <strong>O(n2) –&gt; O(n)</strong></p>
<p><em><strong>可以在<code>for</code>结束以后,再来一遍<code>for</code>判断kv是否存在吗?</strong></em></p>
<p><strong>不可以.</strong> 假设i,j为前缀和数组的下标. 因为对于每个i,实际上要找的j必须有**<code>j &lt;= i</code>,** 否则实际上这个子数组的size就小于0了, 肯定不合法. </p>
<p>但是如果分开两个<code>for</code>做, 找到的<code>(i,j)</code>, 不一定满足这个限制条件. </p>
<p>比如对于<code>k == 1, cur_sum = 3</code>,  可能会有前缀和数组为<code>[... , 2, 3, 5, 2]</code>的情况, 后面一对<code>[3 .. 2]</code>显然不合法. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 前缀和. 优化 T = O(n2) --&gt; O(n) 空间换时间 </span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        presum = collections.defaultdict(<span class="built_in">int</span>) <span class="comment"># &#123;presum : amount of occurance of `presum` &#125;</span></span><br><span class="line">        </span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">            target_sum = cur_sum - k</span><br><span class="line">            <span class="keyword">if</span> presum[target_sum]: <span class="comment"># 存在</span></span><br><span class="line">                ans += presum[target_sum]</span><br><span class="line">            presum[cur_sum] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>





<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Carl</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2021 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>My Heart is in the <strong>WORK</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i> - from <strong>Andrew Carnegie</strong></i></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Interview-Algorithm/"># Interview - Algorithm</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2021/08/05/Git-Related/">Git Related</a>
            
        </section>


    </article>
</div>


<!-- add git talk -->

    <div id="gitalk-container"></div>
    <script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '2cb4dd5456ba994168fe',
        clientSecret: '66d8270f473a683bdc1a1ad00d6d1348b773047b',
        repo: 'Carlwasinfected.github.io',
        owner: 'Carlwasinfected',
        admin: 'Carlwasinfected',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 15,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Carl | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> 
            <br>
        
            <!-- 增加站点统计查询 -->

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    <i>Vistors:</i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;


<span class="site-pv">
    <i>Views:</i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

        </span>
    </div>
</footer>

    </div>
</body>
</html>
